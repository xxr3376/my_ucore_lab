38c38
<                                           |      +--- do_exit --> PROC_ZOMBIE                                +
---
>                                            |      +--- do_exit --> PROC_ZOMBIE                                +
90c90
<     //LAB4:EXERCISE1 2010011358
---
>     //LAB4:EXERCISE1 2010011360
121c121
<      //LAB5 2010011358 : (update LAB4 steps)
---
>      //LAB5 2010011360 : (update LAB4 steps)
127,130c127,130
< 		proc->wait_state = 0;
< 		proc->cptr = NULL;
< 		proc->yptr = NULL;
< 		proc->optr = NULL;
---
>         proc->wait_state = 0;
>         proc->cptr = NULL;
>         proc->yptr = NULL;
>         proc->optr = NULL;
392c392
<     //LAB4:EXERCISE2 2010011358
---
>     //LAB4:EXERCISE2 2010011360
408a409,421
>     proc = alloc_proc();                                    //    1. call alloc_proc to allocate a proc_struct
>     if (proc == NULL) {
>         goto fork_out;
>     }
>     proc->parent = current;                                 //    2. call setup_kstack to allocate a kernel stack for child process
>     int proc_kstack = setup_kstack(proc);   
>     if (proc_kstack != 0) {
>         goto bad_fork_cleanup_proc;
>     }
>     int proc_copy_mm = copy_mm(clone_flags, proc);          //    3. call copy_mm to dup OR share mm according clone_flag
>     if (proc_copy_mm != 0) {
>         goto bad_fork_cleanup_kstack;
>     }
410,417c423,437
<     //    1. call alloc_proc to allocate a proc_struct
<     //    2. call setup_kstack to allocate a kernel stack for child process
<     //    3. call copy_mm to dup OR share mm according clone_flag
<     //    4. call copy_thread to setup tf & context in proc_struct
<     //    5. insert proc_struct into hash_list && proc_list
<     //    6. call wakup_proc to make the new child process RUNNABLE
<     //    7. set ret vaule using child proc's pid
< 	//LAB5 2010011358 : (update LAB4 steps)
---
>     copy_thread(proc, stack, tf);                           //    4. call copy_thread to setup tf & context in proc_struct
> 	bool intr_flag;
>     // save the local situation
> 	local_intr_save(intr_flag);
> 	proc->pid = get_pid();
>     hash_proc(proc);                                        //    5. insert proc_struct into hash_list && proc_list
>     set_links(proc);
> 	local_intr_restore(intr_flag);
>     //list_add(&proc_list, &proc->list_link);
>     //nr_process ++;
> 
>     wakeup_proc(proc);                                      //    6. call wakup_proc to make the new child process RUNNABLE
>     ret = proc->pid;                                        //    7. set ret vaule using child proc's pid
> 
> 	//LAB5 2010011360 : (update LAB4 steps)
424,436d443
< 	proc = alloc_proc();
< 	if (proc == NULL){
< 		goto bad_fork_cleanup_proc;
< 	}
< 	proc->parent = current;
< 	if (setup_kstack(proc)){
< 		goto bad_fork_cleanup_kstack;
< 	}
< 	if (copy_mm(clone_flags, proc)){
< 		goto bad_fork_cleanup_kstack;
< 	}
< 	copy_thread(proc, stack, tf);
< 	//TODO make sure current process's wait_state is 0
438,447d444
< 	bool intr_flag;
< 	local_intr_save(intr_flag);
< 	proc->pid = get_pid();
< 	hash_proc(proc);
< 	list_add_before(&proc_list, &(proc->list_link));
< 	set_links(proc);
< 	local_intr_restore(intr_flag);
< 
< 	wakeup_proc(proc);
< 	ret = proc->pid;
637c634
<     /* LAB5:EXERCISE1 2010011358
---
>     /* LAB5:EXERCISE1 2010011360
646,652c643,650
< 	tf->tf_cs = USER_CS;
< 	tf->tf_ds = USER_DS;
< 	tf->tf_es = USER_DS;
< 	tf->tf_ss = USER_DS;
< 	tf->tf_esp = USTACKTOP;
< 	tf->tf_eip = elf->e_entry;
< 	tf->tf_eflags |= FL_IF;
---
>     tf->tf_cs = USER_CS;
>     tf->tf_ds = USER_DS;
>     tf->tf_es = USER_DS;
>     tf->tf_ss = USER_DS;
>     tf->tf_esp = USTACKTOP;
>     tf->tf_eip = elf->e_entry;
>     // enable Interrupt
>     tf->tf_eflags = FL_IF;
